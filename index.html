<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RunRoute – Map, Distance, Elevation & GPX</title>
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <style>
    :root {
      --panel-bg: rgba(255,255,255,0.92);
      --panel-blur: blur(6px);
      --text: #0f172a;
      --muted: #475569;
      --brand: #0ea5e9;
      --danger: #ef4444;
      --ok: #16a34a;
    }
    html, body, #app { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }
    .panel {
      position: absolute; top: 12px; left: 12px; z-index: 1000;
      backdrop-filter: var(--panel-blur);
      background: var(--panel-bg);
      border-radius: 14px; box-shadow: 0 6px 24px rgba(0,0,0,.15);
      color: var(--text);
      padding: 12px; min-width: 300px; max-width: 460px;
    }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
    .distance { font-size: 24px; font-weight: 700; }
    .muted { color: var(--muted); font-size: 12px; }
    .btns { display: grid; grid-template-columns: repeat(5, minmax(0,1fr)); gap: 8px; margin-top: 10px; }
    button {
      appearance: none; border: 0; padding: 10px 12px; border-radius: 12px; cursor: pointer;
      background: #e2e8f0; font-weight: 600; transition: transform .06s ease, box-shadow .2s ease;
      box-shadow: 0 2px 0 rgba(0,0,0,.12);
      white-space: nowrap;
    }
    button:hover { transform: translateY(-1px); }
    .primary { background: var(--brand); color: white; }
    .danger { background: var(--danger); color: white; }
    .ok { background: var(--ok); color: white; }
    .tiny { font-size: 11px; }
    .legend {
      position: absolute; right: 12px; bottom: 12px; z-index: 1000;
      background: var(--panel-bg); backdrop-filter: var(--panel-blur);
      border-radius: 12px; padding: 8px 10px; color: var(--muted); font-size: 12px;
      box-shadow: 0 6px 24px rgba(0,0,0,.15);
    }
    .toast { position: absolute; left: 50%; transform: translateX(-50%); bottom: 16px; z-index: 1100;
      background: rgba(17,24,39,.9); color: white; padding: 10px 14px; border-radius: 12px; display:none; }
    .stat { display:flex; align-items:center; gap:8px; }
    .stat div { line-height: 1.05; }
    .stat small { display:block; font-size:11px; color:var(--muted); }
    .pill { background:#f1f5f9; padding:6px 8px; border-radius:10px; font-size:12px; }
    .pace-row { display:flex; gap:8px; align-items:center; margin-top:8px; }
    .pace-row input { width:80px; padding:8px 10px; border-radius:10px; border:1px solid #cbd5e1; font-weight:600; }
    @media (max-width: 640px) { .panel { min-width: 0; width: calc(100% - 24px);} .btns{grid-template-columns: repeat(3, minmax(0,1fr));} }
  </style>
</head>
<body>
  <div id="app">
    <div id="map"></div>
    <div class="panel">
      <div class="row">
        <div class="stat">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3 6h18M3 12h18M3 18h18" stroke="#0ea5e9" stroke-width="2" stroke-linecap="round"/></svg>
          <div>
            <div class="distance" id="distance">0.00 km</div>
            <small class="muted" id="segments">0 points • 0 segments</small>
          </div>
        </div>
        <div class="stat">
          <div>
            <div class="pill" id="elev">Elevation gain: — m</div>
            <small class="muted" id="eta">ETA at pace —:—</small>
          </div>
        </div>
        <button id="exportBtn" class="primary" title="Download GPX" disabled>Export GPX</button>
      </div>
      <div class="pace-row">
        <label class="muted">Target pace</label>
        <input id="pace" type="text" inputmode="numeric" placeholder="5:00" title="mm:ss per km"/>
        <button id="paceReset" title="Reset pace">Reset</button>
      </div>
      <div class="btns">
        <button id="startHereBtn" class="ok" title="Add first point at my location">Start Here</button>
        <button id="locateBtn" title="Go to my location">Locate</button>
        <button id="undoBtn" title="Remove last point" disabled>Undo</button>
        <button id="clearBtn" class="danger" title="Clear all" disabled>Clear</button>
        <button id="snapBtn" title="Enable/Disable snap to road">Snap: Off</button>
        <button id="importBtn" title="Import GPX">Import GPX</button>
      </div>
      <input type="file" id="gpxFile" accept=".gpx,application/gpx+xml" style="display:none" />
      <div class="tiny muted" style="margin-top:8px">Click the map to add points. Drag points to refine the route. Double-click to finish a segment.</div>
    </div>
    <div class="legend">Data © OpenStreetMap contributors</div>
    <div class="toast" id="toast"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <!-- Optional: snap-to-road via OpenRouteService (set API key in code). Off by default. -->
  <script>
    // ===== Utilities =====
    const fmtKm = (m) => (m/1000).toFixed(2) + ' km';
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371000; // meters
      const toRad = d => d * Math.PI/180;
      const dLat = toRad(lat2-lat1);
      const dLon = toRad(lon2-lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    function sumDistance(points) {
      let dist = 0;
      for (let i=1;i<points.length;i++) {
        const a = points[i-1], b = points[i];
        dist += haversine(a.lat, a.lng, b.lat, b.lng);
      }
      return dist;
    }
    function toast(msg, ms=1800) {
      const el = document.getElementById('toast');
      el.textContent = msg; el.style.display = 'block';
      setTimeout(()=> el.style.display='none', ms);
    }
    const defer = (ms)=> new Promise(r=>setTimeout(r,ms));

    // ===== Elevation (Open-Elevation API) =====
    const elevationCache = new Map();
    async function getElevation(latlng){
      const key = `${latlng.lat.toFixed(5)},${latlng.lng.toFixed(5)}`;
      if (elevationCache.has(key)) return elevationCache.get(key);
      try {
        const url = `https://api.open-elevation.com/api/v1/lookup?locations=${latlng.lat},${latlng.lng}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('elev fetch failed');
        const data = await res.json();
        const h = data.results?.[0]?.elevation ?? null;
        elevationCache.set(key, h);
        return h;
      } catch(e){
        console.warn('Elevation error', e); return null;
      }
    }
    async function computeElevationGain(points){
      if (points.length < 2) return null;
      let gain = 0; let prev = null;
      for (let i=0;i<points.length;i++){
        const h = await getElevation(points[i]);
        if (h==null) continue;
        if (prev!=null){ const d = h - prev; if (d>0) gain += d; }
        prev = h;
        if (i%25===0) await defer(10); // avoid rate limits
      }
      return Math.round(gain);
    }

    // ===== Pace helpers =====
    function parsePace(str){
      if(!str) return null;
      const m = str.trim().match(/^(\d+):(\d{1,2})$/);
      if(!m) return null;
      const min = parseInt(m[1],10), sec = parseInt(m[2],10);
      return min*60 + sec; // seconds per km
    }
    function fmtHMS(totalSeconds){
      if (totalSeconds==null || !isFinite(totalSeconds)) return '—';
      const s = Math.round(totalSeconds);
      const h = Math.floor(s/3600);
      const m = Math.floor((s%3600)/60);
      const sec = s%60;
      return (h>0? `${h}:` : '') + `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
    }

    // ===== Map Setup =====
    const map = L.map('map', { zoomControl: true }).setView([ -37.8136, 144.9631 ], 13); // Melbourne default
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '© OpenStreetMap'
    }).addTo(map);

    // Layers & State
    const routeLine = L.polyline([], { color: '#0ea5e9', weight: 5, opacity: 0.9 }).addTo(map);
    const markers = []; // L.Marker list mirroring points
    const state = { points: [], snapping: false, orsKey: '' /* optional OpenRouteService API key for snapping */ };

    async function refreshElevationUI(){
      const el = document.getElementById('elev');
      el.textContent = 'Elevation gain: …';
      const gain = await computeElevationGain(state.points);
      el.textContent = `Elevation gain: ${gain==null? '—' : gain + ' m'}`;
    }

    function updateUI() {
      routeLine.setLatLngs(state.points);
      const dist = sumDistance(state.points);
      document.getElementById('distance').textContent = fmtKm(dist);
      document.getElementById('segments').textContent = `${state.points.length} points • ${Math.max(0,state.points.length-1)} segments`;
      const hasPts = state.points.length > 0;
      document.getElementById('undoBtn').disabled = !hasPts;
      document.getElementById('clearBtn').disabled = !hasPts;
      document.getElementById('exportBtn').disabled = state.points.length < 2;

      // Pace ETA
      const p = parsePace(localStorage.getItem('runroute_pace') || document.getElementById('pace').value);
      if (p){
        const etaSec = (dist/1000) * p;
        document.getElementById('eta').textContent = `ETA at pace ${document.getElementById('pace').value || '—'} → ${fmtHMS(etaSec)}`;
      } else {
        document.getElementById('eta').textContent = `ETA at pace —:—`;
      }

      // Elevation
      refreshElevationUI();
    }

    function addPoint(latlng, draggable=true) {
      state.points.push(latlng);
      const mk = L.marker(latlng, { draggable });
      mk.on('drag', (e)=> {
        const idx = markers.indexOf(mk);
        if (idx >= 0) { state.points[idx] = e.target.getLatLng(); updateUI(); }
      });
      mk.on('dragend', ()=> updateUI());
      mk.addTo(map);
      markers.push(mk);
      updateUI();
    }

    function removeLast() {
      if (!state.points.length) return;
      state.points.pop();
      const mk = markers.pop();
      if (mk) mk.remove();
      updateUI();
    }

    function clearAll() {
      state.points.length = 0;
      markers.forEach(m => m.remove());
      markers.length = 0;
      updateUI();
    }

    function exportGPX() {
      if (state.points.length < 2) { toast('Add at least 2 points'); return; }
      const now = new Date();
      const iso = d => d.toISOString();
      // Build GPX XML
      let gpx = '';
      gpx += '<?xml version="1.0" encoding="UTF-8"?>\n';
      gpx += '<gpx version="1.1" creator="RunRoute" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">\n';
      gpx += `  <metadata><time>${iso(now)}</time></metadata>\n`;
      gpx += '  <trk><name>RunRoute Export</name><trkseg>\n';
      for (let i=0;i<state.points.length;i++) {
        const p = state.points[i];
        const t = new Date(now.getTime() + i*1000); // +1s per point
        gpx += `    <trkpt lat="${p.lat}" lon="${p.lng}"><time>${iso(t)}</time></trkpt>\n`;
      }
      gpx += '  </trkseg></trk>\n';
      gpx += '</gpx>';

      const blob = new Blob([gpx], { type: 'application/gpx+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'route.gpx'; a.click();
      URL.revokeObjectURL(url);
      toast('GPX downloaded');
    }

    // GPX Import
    async function importGPX(text){
      try{
        const xml = new DOMParser().parseFromString(text, 'application/xml');
        const pts = Array.from(xml.getElementsByTagName('trkpt'));
        if (!pts.length) { toast('No track points found'); return; }
        clearAll();
        const latlngs = pts.map(n => L.latLng(parseFloat(n.getAttribute('lat')), parseFloat(n.getAttribute('lon'))));
        latlngs.forEach(ll=> addPoint(ll, true));
        map.fitBounds(L.latLngBounds(latlngs), { padding:[30,30] });
        toast('GPX imported');
      } catch(e){ console.warn(e); toast('Failed to import GPX'); }
    }

    // Optional: snap to road using OpenRouteService if API key is present and snapping enabled
    async function snapPointsIfEnabled(latlng) {
      if (!state.snapping || !state.orsKey || state.points.length === 0) return latlng;
      try {
        const last = state.points[state.points.length-1];
        const coords = [[last.lng, last.lat], [latlng.lng, latlng.lat]];
        const params = { coordinates: coords, instructions: false };
        const res = await fetch('https://api.openrouteservice.org/v2/directions/foot-walking/geojson', {
          method: 'POST', headers: { 'Authorization': state.orsKey, 'Content-Type': 'application/json' },
          body: JSON.stringify(params)
        });
        if (!res.ok) throw new Error('Snap failed');
        const data = await res.json();
        const geom = data.features?.[0]?.geometry?.coordinates || [];
        for (let i=1;i<geom.length;i++) {
          const [lng, lat] = geom[i];
          addPoint(L.latLng(lat, lng), true);
        }
        return null;
      } catch (e) {
        console.warn(e);
        toast('Snapping failed – added raw point');
        return latlng;
      }
    }

    // Map interactions
    map.on('click', async (e) => {
      const maybe = await snapPointsIfEnabled(e.latlng);
      if (maybe) addPoint(maybe, true);
    });

    map.on('dblclick', () => toast('Segment finished. Keep clicking to continue.'));

    // Controls
    document.getElementById('undoBtn').addEventListener('click', removeLast);
    document.getElementById('clearBtn').addEventListener('click', clearAll);
    document.getElementById('exportBtn').addEventListener('click', exportGPX);
    document.getElementById('importBtn').addEventListener('click', ()=> document.getElementById('gpxFile').click());
    document.getElementById('gpxFile').addEventListener('change', async (e)=>{
      const file = e.target.files?.[0]; if(!file) return;
      const text = await file.text();
      importGPX(text);
      e.target.value = '';
    });

    document.getElementById('locateBtn').addEventListener('click', () => {
      map.locate({ setView: true, maxZoom: 16 });
    });
    document.getElementById('startHereBtn').addEventListener('click', () => {
      navigator.geolocation.getCurrentPosition((pos)=>{
        const { latitude, longitude } = pos.coords;
        const ll = L.latLng(latitude, longitude);
        addPoint(ll, true);
        map.setView(ll, 16);
        toast('Added starting point at your location');
      }, ()=> toast('Location permission denied'));
    });

    document.getElementById('snapBtn').addEventListener('click', () => {
      state.snapping = !state.snapping;
      document.getElementById('snapBtn').textContent = `Snap: ${state.snapping ? 'On' : 'Off'}`;
      if (state.snapping && !state.orsKey) {
        toast('Set your OpenRouteService API key in code to enable snapping');
      }
    });

    // Pace controls
    const paceInput = document.getElementById('pace');
    const saved = localStorage.getItem('runroute_pace');
    if (saved) paceInput.value = saved;
    paceInput.addEventListener('input', ()=>{
      const val = paceInput.value;
      if (parsePace(val)) localStorage.setItem('runroute_pace', val);
      updateUI();
    });
    document.getElementById('paceReset').addEventListener('click', ()=>{
      localStorage.removeItem('runroute_pace'); paceInput.value = ''; updateUI();
    });

    // Geolocate on load; optional auto-start with ?start=here
    map.once('load', ()=> {
      map.locate({ setView: true, maxZoom: 15 });
      const params = new URLSearchParams(location.search);
      if (params.get('start') === 'here') {
        navigator.geolocation.getCurrentPosition((pos)=>{
          const ll = L.latLng(pos.coords.latitude, pos.coords.longitude);
          addPoint(ll, true);
          map.setView(ll, 16);
        });
      }
    });
    setTimeout(() => map.fire('load'), 300);

    updateUI();
  </script>
</body>
</html>

